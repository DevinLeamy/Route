<!DOCTYPE html>
<!--
   Goal #1: Create a website with a single button that,
   when clicked, will draw a line on the screen.
   [Accomplished]
   Goal #2: Create a wesite with two buttons and two text fields. The text fields will be named
   start and end. In each text field the user will enter a coordinate location. There will also be start and
   end buttons. The start button will draw the shortest path from the start to the end to the screen.
   The end button will clear the screen.
   [Accomplished]
   Goal #3: Change the canvas into a kind of visitedTile and allow the user to select square in the visitedTile. They will be
   able to select the starting point, the ending point and put barriers up. This change also means that the start
   end buttons are going to have a slightly different function. The start button won't change much, when you click
   it it will find the path and the end button will not clear the visitedTile rather than the canvas.
   [Accomplished]
   Goal #3: After selecting two points and putting up barriers, if a path is found between the two points then the a "some colored"
   line be displayed from the start to the end showing the shortest path between the points. Also, show the length of the path.
   [Accomplished]
   Goal #4: Allow the user to create barriers by holding down click.
   [Accomplished]
   Goal #5: Allow the user to delete barriers when holding right click. Add A* search and allow the users to choose between BFS and A*
   with a combo box.
   [Accomplished]
   Goal #6: Have the grid be made when the site is loaded. Move the buttons to the top of the page. Make the grid wider and move it down.
   Display the length of the path.
   [Accomplished]
   Goal #7: Have a default grid setup and allow the user to move the start and end tiles. Blockify the buttons. Fix the length display.
   [Accomplished]
   Goal #8: Have a help button that, when clicked, will tell the user how to use the website.
   Have a remove path button that removes only the paths.
   [Accomplished]
   Goal #9: Create a way to make weighted graphes.
-->
<!--
   Future Features:
   -Unclear how, but, I would like to change the path drawing animation.
   -If you pick a square that has already been picked it changes the color
   of the type of square Types: start, end, wall, paths and path
   -Slow down the tile drawing process, as of now it is too fast and, therefore, is not very imformative.
   -Select starts with "Pick an algorithm", if the user clicks find a path it will default it to Breadth First
   search.
-->
<!--
   Bugs:
   -When dragging the start or end blocks, if the dragged block passes over the opposing block it deletes it. [Fixed]
   -When you drag the blocks outside of the screen it breaks the pathfinding. [Fixed]

-->
<html lang="en" dir="ltr">
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">
      <!-- <script type="text/javascript" src="algorithms.js"></script> -->
      <link rel="stylesheet" href="style.css">
      <title>The_Utimate_Pathfinding_Website</title>
   </head>


   <body>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/js/bootstrap.min.js" integrity="sha384-vZ2WRJMwsjRMW/8U7i6PWi6AlO1L79snBrmgiDpgIWJ82z8eA5lenwvxbMV1PAh7" crossorigin="anonymous"></script>


      <div class="intro">
         <h1 id="intro_header">The Ultimate Pathfinding Website</h1>
      </div>
      <div id="container1">
         <ul id="nav_bar">
            <li><button id="searchBtn" type="button" class="btn btn-danger">Find a Path!</button> </li>
            <li><button id="refreshBtn" type="button" class="btn btn-warning">Restart</button></li>
            <li><select id="pathComboBox">
               <option value="breadthFirstSearch">Breadth First Search</option>
               <option value="AStarSearch">A*</option>
            </select></li>
            <li><button type="button" class="btn btn-info" id="lengthBtn">Length of the Path: <span class="badge" id="lengthLbl">0</span></button></li>
            <li><button type="button" class="btn btn-dark" id="computationsBtn">Number of Operations: <span class="badge" id="computationsLbl">0</span></button></li>
         </ul>
         <span id="helperLbl" class="badge badge-info">??</span>
      </div>
      <div id="grid">
         <canvas id="myCanvas" width="1800" height="1000" oncontextmenu="return false;"></canvas>

      </div>
      <script>
         var canvas = document.getElementById("myCanvas");
         var context = canvas.getContext("2d");
         window.onload = initializeTheGrid;
         canvas.onmousemove = drawBarriers;
         canvas.onmousedown = colorBarriers;
         canvas.onmouseup = stopColoringBarriers;
         canvas.onclick = pickStartAndEnd;
         canvas.onmouseleave = stopColoringBarriers;
         var searchBtn = document.getElementById("searchBtn");
         searchBtn.onclick = handlePathChoice;
         var refreshBtn = document.getElementById("refreshBtn");
         refreshBtn.onclick = removePath;
         refreshBtn.ondblclick = erasePath;
         var lengthLbl = document.getElementById("lengthLbl");
         var computationsLbl = document.getElementById("computationsLbl");
         var helperLbl = document.getElementById("helperLbl");
         helperLbl.onclick = helpUser;
         var TILE_HEIGHT = 40;
         var TILE_WIDTH = 40;
         var NUM_ROWS = 25;
         var NUM_COLS = 45;
         var START_COLOR = "#55d43f";
         var END_COLOR = "#ff0800";
         var PATH_COLOR = "#27aee3";
         var WALL_COLOR = "#36454f";
         var SHORTEST_PATH_COLOR = "#ef820d";
         var GRIDLINES_COLOR = "#808080";
         var ROW_OFFSET = 104;
         var COL_OFFSET = 3;
         var DELAY = 500;
         var GRIDLINES_WIDTH = "1";
         var draggingStart = false;
         var draggingEnd = false;
         var pickedStart = false;
         var pickedEnd = false;
         var startRow = 0;
         var startCol = 0;
         var endRow = 0;
         var endCol = 0;
         var drawTiles = false;
         var eraseTiles = false;
         var isPath = new Array();
         var visitedTile = new Array();
         var distanceFromStart = new Array();
         for (var i = 0; i < NUM_ROWS; i++) {
            visitedTile.push(new Array(NUM_COLS));
            distanceFromStart.push(new Array(NUM_COLS));
            isPath.push(new Array(NUM_COLS));
            for (var j = 0; j < NUM_COLS; j++) {
               visitedTile[i][j] = false;
               distanceFromStart[i][j] = (NUM_COLS * NUM_ROWS) + 1;
               isPath[i][j] = false;
            }
         }

         //Preforms Search
         function breadthFirstSearch() {
            if (!pickedStart || !pickedEnd) {return;}
            //Breath First Search Below
            var currentCoords = new Array();
            var found = false;
            currentCoords.push(new Array(startRow, startCol)); // This should be new Array(startRow, startCol)
            if (startRow == endRow && startCol == endCol) {found = true;}
            var currentDistance = 1;
            var computationsCounted = 0;
            while (!found && currentCoords.length > 0) {
               var newCoords = new Array();
               for (var i = 0; i < currentCoords.length; i++) {
                  var row = currentCoords[i][0];
                  var col = currentCoords[i][1];
                  if (colorIfValid(row+1, col, PATH_COLOR, newCoords, currentDistance, computationsCounted)) {found = true; break;}
                  if (colorIfValid(row-1, col, PATH_COLOR, newCoords, currentDistance, computationsCounted)) {found = true; break;}
                  if (colorIfValid(row, col+1, PATH_COLOR, newCoords, currentDistance, computationsCounted)) {found = true; break;}
                  if (colorIfValid(row, col-1, PATH_COLOR, newCoords, currentDistance, computationsCounted)) {found = true; break;}
               }
               currentCoords = Array.from(newCoords);
               currentDistance++;
            }
            if (found) {
               computationsLbl.textContent = computationsCounted;
               colorShortestPath();
            }
            //Check whether box is valid, if so, it colors it
            function colorIfValid(row, col, color, newCoords) {
               if (row < NUM_ROWS && row >= 0 && col < NUM_COLS && col >= 0 && !visitedTile[row][col]) {
                  newCoords.push(new Array(row, col));
                  visitedTile[row][col] = true;
                  distanceFromStart[row][col] = currentDistance;
                  if (row == endRow && col == endCol) {return true;}
                  isPath[row][col] = true;
                  colorBox(row, col, color);
                  computationsCounted++;
               }
               return false;
            }
         }
         //On canvas click checks if a start and end have been picked
         function pickStartAndEnd() {
            // alert(event.clientX + " " + event.clientY);
            var col = Math.floor((event.clientX - COL_OFFSET) / TILE_WIDTH);
            var row = Math.floor((event.clientY - ROW_OFFSET) / TILE_HEIGHT);
            if (visitedTile[row][col]) {return;}
            if (!pickedStart) {
               pickedStart = true;
               startRow = row;
               startCol = col;
               colorBox(row, col, START_COLOR);
               visitedTile[row][col] = true;
               distanceFromStart[row][col] = 0;
            } else if (!pickedEnd) {
               pickedEnd = true;
               endRow = row;
               endCol = col;
               colorBox(row, col, END_COLOR);
            }
         }
         function aStarSearch() {
            var FLT_MAX = 100000;
            var openList = new Array();
            var closedList = new Array();
            var cellDetails = new Array();
            var computationsCounted = 0;
            for (var i = 0; i < NUM_ROWS; i++) {
               closedList.push(new Array(NUM_COLS));
               cellDetails.push(new Array(NUM_COLS));
               for (var j = 0; j < NUM_COLS; j++) {
                  cellDetails[i][j] = new Array();
                  cellDetails[i][j][0] = FLT_MAX;
                  cellDetails[i][j][1] = FLT_MAX;
                  cellDetails[i][j][2] = FLT_MAX;
                  cellDetails[i][j][3] = -1;
                  cellDetails[i][j][4] = -1;
                  closedList[i][j] = false;
               }
            }
            var row = startRow;
            var col = startCol;
            cellDetails[row][col][0] = 0.0; //f
            cellDetails[row][col][1] = 0.0; //g
            cellDetails[row][col][2] = 0.0; //h
            cellDetails[row][col][3] = row; //parent_row
            cellDetails[row][col][4] = col; //parent_col
            openList.push(new Array(0.0, row, col));
            var foundDest = false;
            //Add distances to
            while (openList.length > 0 && !foundDest) {
               var newG = -1; var newH = -1; var newF = -1;
               var p = openList[0];
               openList.splice(0, 1);
               row = p[1];
               col = p[2];
               closedList[row][col] = true;
               ifValidThenUpdate(row+1, col, row, col);
               computationsCounted++;
               ifValidThenUpdate(row-1, col, row, col);
               computationsCounted++;
               ifValidThenUpdate(row, col+1, row, col);
               computationsCounted++;
               ifValidThenUpdate(row, col-1, row, col);
               computationsCounted++;
            }
            if (foundDest) {
               computationsLbl.textContent = computationsCounted;
               var currentRow = endRow;
               var currentCol = endCol;
               var lengthOfPath = 0;
               while (true) {
                  var tempRow = currentRow;
                  currentRow = cellDetails[currentRow][currentCol][3];
                  currentCol = cellDetails[tempRow][currentCol][4];
                  if (currentRow == startRow && currentCol == startCol) {break;}
                  colorBox(currentRow, currentCol, SHORTEST_PATH_COLOR);
                  lengthOfPath++;
               }
               lengthLbl.textContent = lengthOfPath+1;
            }

            // Helper function
            function ifValidThenUpdate(newRow, newCol, oldRow, oldCol) {
               if (newRow < 0 || newRow >= NUM_ROWS || newCol < 0 || newCol >= NUM_COLS || visitedTile[newRow][newCol]) {return;}
               if (newRow == endRow && newCol == endCol) {
                  cellDetails[newRow][newCol][3] = oldRow;
                  cellDetails[newRow][newCol][4] = oldCol;
                  foundDest = true;
                  return;
               } else if (!closedList[newRow][newCol]) {
                  newG = cellDetails[oldRow][oldCol][1] + 1.0;
                  newH = (Math.abs(newRow - endRow) + Math.abs(newCol - endCol));
                  newF = newG + newH;
                  if (cellDetails[newRow][newCol][0] == FLT_MAX || cellDetails[newRow][newCol][0] > newF) {
                     var currentIndex = 0;
                     var found = false;
                     while (currentIndex < openList.length) {
                        if (openList[currentIndex][0] >= newF) {
                           openList.splice(currentIndex, 0, new Array(newF, newRow, newCol))
                           found = true;
                           break;
                        }
                        currentIndex++;
                     }
                     if (!found) {
                        openList.push(new Array(newF, newRow, newCol));
                     }
                     cellDetails[newRow][newCol][0] = newF;
                     cellDetails[newRow][newCol][1] = newG;
                     cellDetails[newRow][newCol][2] = newH;
                     cellDetails[newRow][newCol][3] = oldRow;
                     cellDetails[newRow][newCol][4] = oldCol;
                     isPath[newRow][newCol] = true;
                     colorBox(newRow, newCol, PATH_COLOR);
                  }
               }
            }
            function getHValue(newRow, newCol) {
               return Math.sqrt(((newRow - endRow) * (newRow - endRow)) + ((newCol - endCol) * (newCol - endCol)));
            }
         }
         //Colors the shortest path if a path exists
         function colorShortestPath() {
            var currentRow = endRow;
            var currentCol = endCol;
            var currentDistance = distanceFromStart[endRow][endCol];
            var lengthOfPath = currentDistance;
            while (currentDistance > 1) {
               if (tryTile(currentRow+1, currentCol)) {currentDistance--; currentRow++;continue;}
               if (tryTile(currentRow-1, currentCol)) {currentDistance--; currentRow--;continue;}
               if (tryTile(currentRow, currentCol+1)) {currentDistance--; currentCol++;continue;}
               if (tryTile(currentRow, currentCol-1)) {currentDistance--; currentCol--;continue;}
            }
            lengthLbl.textContent = lengthOfPath;
            //Helper function
            function tryTile(row, col) {
               if (row < NUM_ROWS && row >= 0 && col < NUM_COLS && col >= 0) {
                  if (distanceFromStart[row][col] == currentDistance-1) {
                     colorBox(row, col, SHORTEST_PATH_COLOR);
                     return true;
                  }
               }
               return false;
            }
         }
         //Resets the board
         function erasePath() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < NUM_ROWS; i++) {
               for (var j = 0; j < NUM_COLS; j++) {
                  visitedTile[i][j] = false;
                  distanceFromStart[i][j] = (TILE_WIDTH + TILE_HEIGHT) +1;
                  isPath[i][j] = false;
               }
            }

            initializeTheGrid();
            lengthLbl.textContent = "0";
            computationsLbl.textContent = "0";
            drawTiles = false;
            eraseTiles = false;
            draggingEnd = false;
            draggingStart = false;
         }
         //Colors a box
         function colorBox(row, col, color) {
            context.beginPath();
            context.lineWidth = GRIDLINES_WIDTH;
            context.fillStyle = color;
            context.rect(col*TILE_WIDTH, row*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
            context.strokeStyle = GRIDLINES_COLOR;
            context.stroke();
            context.fillRect(col*TILE_WIDTH, row*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
         }
         //Draws Barriers
         function drawBarriers() {
            var col = Math.floor((event.clientX - COL_OFFSET) / TILE_WIDTH);
            var row = Math.floor((event.clientY - ROW_OFFSET) / TILE_HEIGHT);
            if (draggingStart) {
               replaceStart(row, col);
               return;
            } else if (draggingEnd) {
               replaceEnd(row, col);
               return;
            }
            if (!drawTiles && !eraseTiles) {return;}
            if ((row == startRow && col == startCol) || (row == endRow && col == endCol)) {return;}
            else if (drawTiles){
               colorBox(row, col, WALL_COLOR);
               visitedTile[row][col] = true;
            } else {
               context.clearRect(col*TILE_WIDTH, row*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
               context.beginPath();
               context.lineWidth = GRIDLINES_WIDTH;
               context.rect(col*TILE_WIDTH, row*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
               context.strokeStyle = GRIDLINES_COLOR;
               context.stroke();
               visitedTile[row][col] = false;
            }
         }
         //Lets barriers be colored
         function colorBarriers() {
            // alert(event.clientX + " " + event.clientY);
            var imageData = context.getImageData(event.clientX - COL_OFFSET, event.clientY-ROW_OFFSET, 1, 1).data;
            var hexColor = rgbToHex(imageData[0], imageData[1], imageData[2]);
            if (hexColor == END_COLOR) {draggingEnd = true;}
            else if (hexColor == START_COLOR) {draggingStart = true;}
            else {
               var buttonClicked = event.button;
               if (buttonClicked == 2) {
                  eraseTiles = true;
                  drawTiles = false;
               } else if (buttonClicked == 0) {
                  drawTiles = true;
                  eraseTiles = false;
               }
            }
         }
         //Stops the coloring of barriers
         function stopColoringBarriers() {
            eraseTiles = false;
            drawTiles = false;
            draggingStart = false;
            draggingEnd = false;
         }
         //Makes an empty grid
         function makeGrid() {
            for (var i = 0; i < NUM_ROWS; i++) {
               for (var j = 0; j < NUM_COLS; j++) {
                  context.beginPath();
                  context.lineWidth = GRIDLINES_WIDTH;
                  context.rect(j*TILE_WIDTH, i*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
                  context.strokeStyle = GRIDLINES_COLOR;
                  context.stroke();
               }
            }
         }
         function handlePathChoice() {
            var algorithm = document.getElementById("pathComboBox").value;
            if (algorithm == "breadthFirstSearch") {
               breadthFirstSearch();
            } else if (algorithm == "AStarSearch") {
               aStarSearch();
            }
         }
         function rgbToHex(red, green, blue) {
            var rgb = blue | (green << 8) | (red << 16);
            return '#' + (0x1000000 + rgb).toString(16).slice(1)
         }
         function replaceStart(row, col) {
            if (row == endRow && col == endCol) {return;}
            visitedTile[startRow][startCol] = false;
            visitedTile[row][col] = true;
            redraw(startRow, startCol);
            colorBox(row, col, START_COLOR);
            startRow = row;
            startCol = col;
         }
         function replaceEnd(row, col) {
            if (row == startRow && col == startCol) {return;}
            visitedTile[row][col] = false;
            redraw(endRow, endCol);
            colorBox(row, col, END_COLOR);
            endRow = row;
            endCol = col;
         }
         function redraw(row, col) {
            context.clearRect(col*TILE_WIDTH, row*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
            context.beginPath();
            context.lineWidth = GRIDLINES_WIDTH;
            context.rect(col*TILE_WIDTH, row*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
            context.strokeStyle = GRIDLINES_COLOR;
            context.stroke();
         }
         function initializeTheGrid() {
            makeGrid();
            pickedStart = true;
            startRow = 10;
            startCol = 15;
            pickedEnd = true;
            visitedTile[startRow][startCol] = true;
            endRow = 10;
            endCol = 29;
            colorBox(startRow, startCol, START_COLOR);
            colorBox(endRow, endCol, END_COLOR);
         }
         function removePath() {
            visitedTile[endRow][endCol] = false;
            for (var i = 0; i < NUM_ROWS; i++) {
               for (var j = 0; j < NUM_COLS; j++) {
                  if (isPath[i][j]) {
                     isPath[i][j] = false;
                     visitedTile[i][j] = false;
                     distanceFromStart[i][j] = (TILE_WIDTH + TILE_HEIGHT) +1;
                     context.clearRect(j*TILE_WIDTH, i*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
                     context.beginPath();
                     context.lineWidth = GRIDLINES_WIDTH;
                     context.rect(j*TILE_WIDTH, i*TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT);
                     context.strokeStyle = GRIDLINES_COLOR;
                     context.stroke();
                  }
               }
            }
            lengthLbl.textContent = "0";
            computationsLbl.textContent = "0";
         }
         function helpUser() {
            alert("Green Node: Start \nRed Node: End \nFind a Path!: Finds the path between two nodes\nRestart: Double click to clear board, single to clear path \nBreadth First Search: An array of path finding algorithms \nDraw Barriers: Drag left click \nDelete Barriers: Drag right click")
         }
      </script>
   </body>
</html>
